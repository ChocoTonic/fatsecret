import base64
import datetime
import hashlib
import hmac
import time
import urllib
import uuid
from typing import Optional, Tuple, Union

import requests
from rauth.service import OAuth1Service

from .errors import (ApplicationError, AuthenticationError, GeneralError,
                     ParameterError)


class FatsecretCore:
    """Core FatSecret API client logic (auth, request handling, utilities)."""

    REQUEST_TOKEN_URL = "https://authentication.fatsecret.com/oauth/request_token"
    AUTHORIZE_URL = "https://authentication.fatsecret.com/oauth/authorize"
    ACCESS_TOKEN_URL = "https://authentication.fatsecret.com/oauth/access_token"
    BASE_URL = "https://platform.fatsecret.com/rest/server.api"

    def __init__(
        self,
        consumer_key: str,
        consumer_secret: str,
        session_token: Optional[Tuple[str, str]] = None,
    ):
        """Initialize the FatSecret API session.

        Args:
            consumer_key: API consumer key (register at https://platform.fatsecret.com/api)
            consumer_secret: API consumer secret
            session_token: Optional (token, secret) tuple for an existing authenticated session
        """
        self.consumer_key = consumer_key
        self.consumer_secret = consumer_secret

        # Needed for new access. Generated by running get_authorize_url()
        self.request_token = None
        self.request_token_secret = None

        # Required for accessing user info. Generated by running authenticate()
        self.access_token = None
        self.access_token_secret = None

        self.oauth = OAuth1Service(
            name="fatsecret",
            consumer_key=consumer_key,
            consumer_secret=consumer_secret,
            request_token_url=self.REQUEST_TOKEN_URL,
            authorize_url=self.AUTHORIZE_URL,
            access_token_url=self.ACCESS_TOKEN_URL,
            base_url=self.BASE_URL,
        )

        # Open prior session or default to unauthorized session
        if session_token:
            self.access_token = session_token[0]
            self.access_token_secret = session_token[1]
            self.session = self.oauth.get_session(token=session_token)
        else:
            # Default to unauthorized session
            self.session = self.oauth.get_session()

    @property
    def api_url(self) -> str:
        return self.oauth.base_url

    def get_authorize_url(self, callback_url: str = "oob") -> str:
        """
        New implementation using manual OAuth 1.0 flow to /oauth/request_token on the new endpoint.

        :param callback_url: An absolute URL to redirect the User to when they have completed authentication
        :type callback_url: str
        """
        print("Generating request token...")

        oauth_consumer_key = self.consumer_key
        oauth_consumer_secret = self.consumer_secret
        oauth_signature_method = "HMAC-SHA1"
        oauth_timestamp = str(int(time.time()))
        oauth_nonce = str(uuid.uuid4().hex)
        oauth_version = "1.0"
        oauth_callback = callback_url

        # Collect parameters for base string
        params = {
            "oauth_consumer_key": oauth_consumer_key,
            "oauth_signature_method": oauth_signature_method,
            "oauth_timestamp": oauth_timestamp,
            "oauth_nonce": oauth_nonce,
            "oauth_version": oauth_version,
            "oauth_callback": oauth_callback,
        }

        base_params = "&".join(
            [
                "{}={}".format(
                    urllib.parse.quote(k, safe=""), urllib.parse.quote(v, safe="")
                )
                for k, v in sorted(params.items())
            ]
        )
        method = "POST"
        base_url = self.oauth.request_token_url
        signature_base_string = "&".join(
            [
                method,
                urllib.parse.quote(base_url, safe=""),
                urllib.parse.quote(base_params, safe=""),
            ]
        )

        signing_key = f"{urllib.parse.quote(oauth_consumer_secret, safe='')}&"

        hashed = hmac.new(
            signing_key.encode("utf-8"),
            signature_base_string.encode("utf-8"),
            hashlib.sha1,
        )
        oauth_signature = base64.b64encode(hashed.digest()).decode()

        params["oauth_signature"] = oauth_signature

        headers = {
            "Content-Type": "application/x-www-form-urlencoded",
        }

        full_request_url = f"{base_url}?{urllib.parse.urlencode(params)}"
        print("Full request URL ends with:", full_request_url[-4:])

        # POST request to fetch request_token
        response = requests.post(base_url, data=params, headers=headers)
        response.raise_for_status()
        result = dict(urllib.parse.parse_qsl(response.text))

        self.request_token = result["oauth_token"]
        self.request_token_secret = result["oauth_token_secret"]
        print(f"Request token ends with: {self.request_token[-4:]}")
        print(f"secret ends with: {self.request_token_secret[-4:]}")

        return f"{self.oauth.authorize_url}?oauth_token={self.request_token}"

    def authenticate(self, verifier: Union[str, int]) -> Tuple[str, str]:
        """Exchange the verifier (PIN or callback code) for permanent access tokens.

        Args:
            verifier: PIN displayed to user or returned via callback.
        Returns:
            (access_token, access_secret)
        """
        session_token = self.oauth.get_access_token(
            self.request_token,
            self.request_token_secret,
            params={"oauth_verifier": verifier},
        )

        self.access_token = session_token[0]
        self.access_token_secret = session_token[1]
        self.session = self.oauth.get_session(session_token)

        # Return session token for app specific caching
        return session_token

    def close(self) -> None:
        """Close the current HTTP session."""
        self.session.close()

    @staticmethod
    def unix_time(dt: datetime.datetime) -> int:
        """Convert a datetime to number of days since the Epoch (FatSecret style)."""
        epoch = datetime.datetime.fromtimestamp(0, datetime.timezone.utc).replace(
            tzinfo=None
        )
        delta = dt - epoch
        return delta.days

    @staticmethod
    def unix_time_v2(dt: Union[datetime.datetime, datetime.date, int, float]) -> int:
        """Convert datetime/date/timestamp into number of days since 1970-01-01."""
        epoch = datetime.datetime(1970, 1, 1)
        if isinstance(dt, datetime.datetime):
            delta = dt - epoch
            return delta.days
        elif isinstance(dt, datetime.date):
            delta = datetime.datetime(dt.year, dt.month, dt.day) - epoch
            return delta.days
        elif isinstance(dt, (int, float)):
            # treat as unix timestamp, use timezone-aware UTC
            dt_utc = datetime.datetime.fromtimestamp(
                dt, tz=datetime.timezone.utc
            ).replace(tzinfo=None)
            delta = dt_utc - epoch
            return delta.days
        else:
            raise TypeError("dt must be datetime, date, int, or float")

    @staticmethod
    def valid_response(response: requests.Response):
        """Validate a JSON API response and extract its data or raise an error."""
        if response.json():

            for key in response.json():

                # Error Code Handling
                if key == "error":
                    code = response.json()[key]["code"]
                    message = response.json()[key]["message"]
                    if code == 2:
                        raise AuthenticationError(
                            2, "This api call requires an authenticated session"
                        )

                    elif code in [1, 10, 11, 12, 20, 21]:
                        raise GeneralError(code, message)

                    elif 3 <= code <= 9:
                        raise AuthenticationError(code, message)

                    elif 101 <= code <= 108:
                        raise ParameterError(code, message)

                    elif 201 <= code <= 207:
                        raise ApplicationError(code, message)

                # All other response options
                elif key == "success":
                    return True

                elif key == "foods":
                    return response.json()[key]["food"]

                elif key == "suggestions":
                    return response.json()[key]

                elif key == "recipes":
                    return response.json()[key]["recipe"]

                elif key == "saved_meals":
                    return response.json()[key]["saved_meal"]

                elif key == "saved_meal_items":
                    return response.json()[key]["saved_meal_item"]

                elif key == "exercise_types":
                    return response.json()[key]["exercise"]

                elif key == "food_entries":
                    if response.json()[key] is None:
                        return []
                    entries = response.json()[key]["food_entry"]
                    if isinstance(entries, dict):
                        return [entries]
                    elif isinstance(entries, list):
                        return entries

                elif key == "month":
                    return response.json()[key]["day"]

                elif key == "profile":
                    if "auth_token" in response.json()[key]:
                        return (
                            response.json()[key]["auth_token"],
                            response.json()[key]["auth_secret"],
                        )
                    else:
                        return response.json()[key]

                elif key in (
                    "food",
                    "recipe",
                    "recipe_types",
                    "saved_meal_id",
                    "saved_meal_item_id",
                    "food_entry_id",
                ):
                    return response.json()[key]
