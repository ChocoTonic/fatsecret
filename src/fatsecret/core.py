import datetime
from typing import Optional, Tuple, Union

import requests
from requests_oauthlib import OAuth1Session

from .errors import (ApplicationError, AuthenticationError, GeneralError,
                     ParameterError)


class FatsecretCore:
    """Core FatSecret API client logic (auth, request handling, utilities)."""

    REQUEST_TOKEN_URL = "https://authentication.fatsecret.com/oauth/request_token"
    AUTHORIZE_URL = "https://authentication.fatsecret.com/oauth/authorize"
    ACCESS_TOKEN_URL = "https://authentication.fatsecret.com/oauth/access_token"
    BASE_URL = "https://platform.fatsecret.com/rest/server.api"

    def __init__(
        self,
        consumer_key: str,
        consumer_secret: str,
        session_token: Optional[Tuple[str, str]] = None,
    ):
        """Initialize the FatSecret API session.

        Args:
            consumer_key: API consumer key (register at https://platform.fatsecret.com/api)
            consumer_secret: API consumer secret
            session_token: Optional (token, secret) tuple for an existing authenticated session
        """
        self.consumer_key = consumer_key
        self.consumer_secret = consumer_secret

        # Needed for new access. Generated by running get_authorize_url()
        self.request_token = None
        self.request_token_secret = None

        # Required for accessing user info. Generated by running authenticate()
        self.access_token = None
        self.access_token_secret = None

        # Create an OAuth1Session for request signing. If a session_token is
        # provided we initialize a user-authenticated session; otherwise the
        # session will sign requests using only the consumer key/secret.
        if session_token:
            self.access_token = session_token[0]
            self.access_token_secret = session_token[1]
            self.session = OAuth1Session(
                self.consumer_key,
                client_secret=self.consumer_secret,
                resource_owner_key=self.access_token,
                resource_owner_secret=self.access_token_secret,
            )
        else:
            self.session = OAuth1Session(
                self.consumer_key, client_secret=self.consumer_secret
            )

    @property
    def api_url(self) -> str:
        return self.BASE_URL

    def get_authorize_url(self, callback_url: str = "oob") -> str:
        """
        New implementation using manual OAuth 1.0 flow to /oauth/request_token on the new endpoint.

        :param callback_url: An absolute URL to redirect the User to when they have completed authentication
        :type callback_url: str
        """
        print("Generating request token...")

        oauth = OAuth1Session(
            self.consumer_key,
            client_secret=self.consumer_secret,
            callback_uri=callback_url,
        )

        fetch_response = oauth.fetch_request_token(self.REQUEST_TOKEN_URL)

        # fetch_response is a dict with oauth_token and oauth_token_secret
        self.request_token = fetch_response.get("oauth_token")
        self.request_token_secret = fetch_response.get("oauth_token_secret")
        if self.request_token:
            print(f"Request token ends with: {self.request_token[-4:]}")
        if self.request_token_secret:
            print(f"secret ends with: {self.request_token_secret[-4:]}")

        # authorization_url will append oauth_token for us
        return oauth.authorization_url(self.AUTHORIZE_URL)

    def authenticate(self, verifier: Union[str, int]) -> Tuple[str, str]:
        """Exchange the verifier (PIN or callback code) for permanent access tokens.

        Args:
            verifier: PIN displayed to user or returned via callback.
        Returns:
            (access_token, access_secret)
        """
        oauth = OAuth1Session(
            self.consumer_key,
            client_secret=self.consumer_secret,
            resource_owner_key=self.request_token,
            resource_owner_secret=self.request_token_secret,
            verifier=str(verifier),
        )

        token_response = oauth.fetch_access_token(self.ACCESS_TOKEN_URL)

        # token_response contains oauth_token and oauth_token_secret
        self.access_token = token_response.get("oauth_token")
        self.access_token_secret = token_response.get("oauth_token_secret")

        # Create a session signed with the new access token for subsequent
        # authenticated requests.
        self.session = OAuth1Session(
            self.consumer_key,
            client_secret=self.consumer_secret,
            resource_owner_key=self.access_token,
            resource_owner_secret=self.access_token_secret,
        )

        # Return session token for app specific caching
        return (self.access_token, self.access_token_secret)

    def close(self) -> None:
        """Close the current HTTP session if present.

        Defensive: do not raise if session is None or doesn't support close().
        """
        session = getattr(self, "session", None)
        if session is None:
            return
        # Some session objects may not implement close() or may already be
        # closed; guard against exceptions.
        try:
            close_fn = getattr(session, "close", None)
            if callable(close_fn):
                close_fn()
        except Exception:
            # Swallow exceptions during close to keep tear-down robust.
            pass

    @staticmethod
    def unix_time(dt: datetime.datetime) -> int:
        """Convert a datetime to number of days since the Epoch (FatSecret style)."""
        epoch = datetime.datetime.fromtimestamp(0, datetime.timezone.utc).replace(
            tzinfo=None
        )
        delta = dt - epoch
        return delta.days

    @staticmethod
    def unix_time_v2(dt: Union[datetime.datetime, datetime.date, int, float]) -> int:
        """Convert datetime/date/timestamp into number of days since 1970-01-01."""
        epoch = datetime.datetime(1970, 1, 1)
        if isinstance(dt, datetime.datetime):
            delta = dt - epoch
            return delta.days
        elif isinstance(dt, datetime.date):
            delta = datetime.datetime(dt.year, dt.month, dt.day) - epoch
            return delta.days
        elif isinstance(dt, (int, float)):
            # treat as unix timestamp, use timezone-aware UTC
            dt_utc = datetime.datetime.fromtimestamp(
                dt, tz=datetime.timezone.utc
            ).replace(tzinfo=None)
            delta = dt_utc - epoch
            return delta.days
        else:
            raise TypeError("dt must be datetime, date, int, or float")

    @staticmethod
    def valid_response(response: requests.Response):
        """Validate a JSON API response and extract its data or raise an error.

        This method parses the JSON payload once and uses explicit key checks
        so the behavior is clearer and avoids repeated .json() calls.
        """
        try:
            data = response.json()
        except ValueError:
            # If the response is not JSON raise for status so the caller gets
            # an informative HTTP error.
            response.raise_for_status()
            return None

        if not data:
            return None

        # Error handling
        if "error" in data:
            err = data["error"]
            code = err.get("code")
            message = err.get("message")
            if code == 2:
                raise AuthenticationError(
                    2, "This api call requires an authenticated session"
                )
            elif code in [1, 10, 11, 12, 20, 21]:
                raise GeneralError(code, message)
            elif 3 <= code <= 9:
                raise AuthenticationError(code, message)
            elif 101 <= code <= 108:
                raise ParameterError(code, message)
            elif 201 <= code <= 207:
                raise ApplicationError(code, message)

        # Non-error payloads
        if "success" in data:
            return True

        if "foods" in data:
            return data["foods"].get("food")

        if "suggestions" in data:
            return data["suggestions"]

        if "recipes" in data:
            return data["recipes"].get("recipe")

        if "saved_meals" in data:
            return data["saved_meals"].get("saved_meal")

        if "saved_meal_items" in data:
            return data["saved_meal_items"].get("saved_meal_item")

        if "exercise_types" in data:
            return data["exercise_types"].get("exercise")

        if "food_entries" in data:
            if data["food_entries"] is None:
                return []
            entries = data["food_entries"].get("food_entry")
            if isinstance(entries, dict):
                return [entries]
            return entries

        if "month" in data:
            return data["month"].get("day")

        if "profile" in data:
            profile = data["profile"]
            if "auth_token" in profile:
                return (profile.get("auth_token"), profile.get("auth_secret"))
            return profile

        for single_key in (
            "food",
            "recipe",
            "recipe_types",
            "saved_meal_id",
            "saved_meal_item_id",
            "food_entry_id",
        ):
            if single_key in data:
                return data[single_key]
        return None
